[
  "const { Shape, RectangularGrid, RectangularTile, Search, Position } = Gridy\n\nconst size = 7\n\nconst grid = new RectangularGrid(28, false, Shape.Rhombus, size, size)\n\nconst highlight = []\n\nhighlight.push(new Position(0, 0))\nhighlight.push(new Position(size - 1, size - 1))\n\ngrid.tiles.forEach((t, i) => {\n  if (!(t.x & t.y % 3)) {\n    highlight.push(t)\n  }\n})\n\nconst search = new Search(\n  new RectangularTile(),\n  Infinity,\n  100,\n  undefined,\n  highlight\n)\n\nconst path = search.path(grid.tile(size - 1, size - 1))\n\nreturn { grid, highlight, search, path }",
  "const { Shape, HexagonalGrid, HexagonalTile, Search, circle } = Gridy\n\nconst grid = new HexagonalGrid(32, true, Shape.Hexagonal, 14)\n\nconst center = new HexagonalTile()\nlet t = []\nconst highlight = []\n  .concat(((t = circle(center, 1)).splice(5, 1), t))\n  .concat(((t = circle(center, 3)).splice(2, 1), t))\n  .concat(((t = circle(center, 5)).splice(18, 1), t))\n  .concat(((t = circle(center, 7)).splice(33, 1), t))\n  .concat(((t = circle(center, 9)).splice(7, 1), t))\n  .concat(((t = circle(center, 11)).splice(22, 1), t))\n\nconst search = new Search(\n  center,\n  Infinity,\n  100,\n  highlight,\n  grid.tiles\n)\n\nconst path = search.path(grid.tile(-12, 0))\n\nreturn { grid, highlight, path, width: 456 * 2 }",
  "const { Shape, HexagonalGrid, HexagonalTile, Search } = Gridy\n\nconst grid = new HexagonalGrid(70, true, Shape.Rhombus, 4, 4)\n\nconst search = new Search(\n  new HexagonalTile(),\n  Infinity,\n  8,\n  undefined,\n  grid.tiles\n)\n\nconst path = search.path(grid.tile(3, 3))\n\nreturn { grid, showTiles: true, path, showCoordinates: true }",
  "const { Shape, HexagonalGrid, HexagonalTile, Search } = Gridy\n\nconst grid = new HexagonalGrid(70, true, Shape.Rhombus, 4, 4)\n\nconst blocked = [\n  grid.tile(1, 0),\n  grid.tile(2, 1),\n  grid.tile(1, 3),\n  grid.tile(2, 2)\n]\n\nconst search = new Search(\n  new HexagonalTile(),\n  Infinity,\n  8,\n  blocked,\n  grid.tiles\n)\n\nconst path = search.path(grid.tile(3, 3))\n\nreturn { grid, showTiles: true, path, showCoordinates: true, highlight: blocked }",
  "const { Shape, RectangularGrid, RectangularTile, Search } = Gridy\n\nconst grid = new RectangularGrid(40, true, Shape.Rhombus, 5, 5)\n\nconst blocked = [\n  grid.tile(1, 0),\n  grid.tile(2, 1),\n  grid.tile(1, 3),\n  grid.tile(2, 2)\n]\n\nconst search = new Search(\n  new RectangularTile(),\n  Infinity,\n  8,\n  blocked,\n  grid.tiles\n)\n\nconst path = search.path(grid.tile(4, 0))\n\nreturn { grid, path, showCoordinates: true, highlight: blocked }",
  "const { Shape, RectangularGrid, RectangularTile, Search } = Gridy\n\nconst size = 24\n\nconst grid = new RectangularGrid(14, false, Shape.Rhombus, size, size)\n\nconst blocked = []\n\nfor (let i = 0; i < size * size / 2; i++) {\n  blocked.push(new RectangularTile(\n    Math.floor(Math.random() * size + 1),\n    Math.floor(Math.random() * (size - 1))\n  ))\n}\n\nconst search = new Search(\n  new RectangularTile(),\n  Infinity,\n  100,\n  blocked,\n  grid.tiles\n)\n\nconst max = Math.max.apply(null, grid.tiles.map(t => search.cost[t.key] || -1))\n\nconst end = grid.tiles.find(t => search.cost[t.key] === max)\n\nconst path = search.path(end)\n\nreturn { grid, highlight: blocked, search, path, highlightDark: true }",
  "const { Shape, HexagonalGrid, Search } = Gridy\n\nconst size = 11\n\nconst grid = new HexagonalGrid(24, true, Shape.Rhombus, size, size)\n\nconst starts = []\nconst ends = []\n\nfor (let i = 0; i < size; i++) {\n  starts.push(grid.tile(0, i))\n  ends.push(grid.tile(size - 1, i))\n}\n\nconst highlight = grid.tiles.filter((s, i) => !((s.x - s.y) % 3) || !((i + s.x) % 7))\n\nconst search = new Search(\n  starts,\n  Infinity,\n  100,\n  highlight,\n  grid.tiles\n)\n\nconst path = search.path(ends)\n\nreturn { grid, highlight, highlightDark: true, search, values: search.cost, path }",
  "const { Shape, HexagonalGrid, connections } = Gridy\n\nconst size = 11\n\nconst grid = new HexagonalGrid(24, true, Shape.Rhombus, size, size)\n\nconst highlight = grid.tiles.filter((s, i) => ((s.x - s.y) % 3) || !((i + s.x) % 8))\n\nconst lines = connections(highlight).filter((l) => l.length === 5)\n\nreturn { grid, lines, highlight }",
  "const { Shape, RectangularGrid, Rectangular8Tile, connections } = Gridy\n\nconst size = 11\n\nconst grid = new RectangularGrid(24, false, Shape.Rhombus, size, size, Rectangular8Tile)\n\nconst highlight = grid.tiles.filter((s, i) => ((s.x - s.y) % 3) || !((i + s.x) % 8))\n\nconst lines = connections(highlight).filter((l) => l.length === 5)\n\nreturn { grid, lines, highlight }",
  "const { Shape, TriangularGrid, connections } = Gridy\n\nconst size = 11\n\nconst grid = new TriangularGrid(24, false, Shape.Triangular, size, size)\n\nconst highlight = grid.tiles.filter((s, i) => [13, 50, 98].indexOf(i) === -1)\n\nconst lines = connections(highlight).filter((l) => l.length <= 7 && l.length >= 3)\n\nreturn { grid, lines, highlight }",
  "const { Shape, TriangularGrid, border } = Gridy\n\nconst size = 11\n\nconst grid = new TriangularGrid(24, false, Shape.Triangular, size, size)\n\nconst highlight = border(grid.tiles)\n\nreturn { grid, highlight }",
  "const { Shape, HexagonalGrid, outline } = Gridy\n\nconst size = 3\n\nconst grid = new HexagonalGrid(48, false, Shape.Hexagonal, size, size)\n\nconst highlight = outline(grid.tiles)\ngrid.tiles = grid.tiles.concat(highlight)\n\nreturn { grid, highlight }",
  "const { Shape, TriangularGrid, outline } = Gridy\n\nconst size = 3\n\nconst grid = new TriangularGrid(48, false, Shape.Triangular, size, size)\n\nconst highlight = outline(grid.tiles)\ngrid.tiles = grid.tiles.concat(highlight)\n\nreturn { grid, highlight }"
]